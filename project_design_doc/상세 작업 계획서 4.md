---
root_main: "[[프로젝트/프로젝트_main|프로젝트_main]]"
deps: 0
title: 상세 작업 계획서 4
Project: 
Domain: 
Object: 
Scope: 
Asset: 
Source:
Maturity (%): 
entity_type: 
created: 2025-06-26
modified: 2025-06-26 14:00
folder_main: "[[프로젝트/프로젝트_main|프로젝트_main]]"
related_files:
---
### **Part 4: 프레젠테이션 계층 상세 설계 (src/app.py) (심화)**

이전 파트에서 src/app.py의 기본 구조와 로직 흐름을 설계했다. 이 파트에서는 사용자 경험(UX)을 극대화하기 위한 구체적인 시각화 컴포넌트 구현 방법을 상세히 정의한다.

#### **4.1. 메인 결과 디스플레이 상세 설계**

st.session\_state.results가 채워졌을 때, 메인 화면에 표시될 각 컴포넌트의 명세이다.

1. **페르소나 분석 결과 (st.expander)**:  
   * **컴포넌트**: st.expander("선택된 페르소나 분석 결과 보기")를 사용하여 기본적으로 내용을 숨기고, 사용자가 원할 때 펼쳐볼 수 있도록 한다.  
   * **내부 레이아웃**: st.columns(2)를 사용하여 2단 레이아웃으로 구성한다.  
     * **좌측 컬럼**:  
       * st.subheader(f"👤 {persona\_name}")  
       * st.caption(f"{persona\_description}")  
       * st.markdown("---")  
       * st.write("📈 \*\*가상 시청 기록 (Top 10)\*\*")  
       * st.dataframe(dummy\_watch\_history.head(10))를 사용하여 생성된 시청 기록 일부를 테이블로 표시한다.  
     * **우측 컬럼**:  
       * st.write("🧠 \*\*잠재 선호 영화 클러스터 및 AI 생성 라벨\*\*")  
       * top\_k\_movies\_with\_labels 리스트를 순회하며 각 영화 정보를 카드 형태로 표시한다.  
       * **카드 컴포넌트 의사 코드**:  
         \# In app.py  
         for movie in results\['top\_k\_movies\_with\_labels'\]:  
             with st.container():  
                 st.markdown(f"\*\*{movie\['title'\]}\*\* (예상 평점: {movie\['predicted\_rating'\]:.1f})")  
                 \# 라벨들을 st.button(disabled=True)를 사용해 태그처럼 보이게 함  
                 cols \= st.columns(5)   
                 for i, label in enumerate(movie\['labels'\]\[:5\]):  
                     cols\[i % 5\].button(label, key=f"{movie\['title'\]}\_{label}", disabled=True)

2. **실시간 채널 추천 결과**:  
   * st.subheader("📺 지금 시청할 만한 채널 추천")  
   * results\['recommendations'\] 리스트를 순회하며 각 추천 항목을 표시한다.  
   * **커스텀 카드 컴포넌트 설계 (HTML/CSS 사용)**: st.markdown의 unsafe\_allow\_html=True 옵션을 활용하여 UI를 미려하게 꾸민다.  
     * **카드 구조**:  
       * 채널 로고 (이미지 파일 또는 이모지)  
       * 채널명 및 채널 번호  
       * 프로그램 제목 및 회차 정보  
       * 방영 시간 (e.g., 21:00 \~ 22:30)  
       * 유사도 점수를 시각화한 프로그레스 바  
       * AI가 분석한 추천 이유  
       * '이어서 보기' 버튼  
     * **HTML/CSS 예시 코드**:  
       \# In app.py, to be used inside a loop  
       def create\_recommendation\_card(program\_data):  
           card\_html \= f"""  
           \<div style="border: 1px solid \#e6e6e6; border-radius: 10px; padding: 15px; margin-bottom: 10px; box-shadow: 2px 2px 8px rgba(0,0,0,0.1);"\>  
               \<h3 style="margin-bottom: 5px;"\>{program\_data\['channel'\]} \- {program\_data\['title'\]}\</h3\>  
               \<p style="font-size: 0.9em; color: grey;"\>{program\_data\['start\_time'\]} \~ {program\_data\['end\_time'\]}\</p\>  
               \<label\>AI 추천 유사도: {int(program\_data\['similarity\_score'\] \* 100)}%\</label\>  
               \<progress value="{program\_data\['similarity\_score'\]}" max="1" style="width: 100%;"\>\</progress\>  
               \<p style="font-size: 0.9em; margin-top: 10px;"\>\<b\>추천 이유:\</b\> {program\_data\['reason'\]}\</p\>  
           \</div\>  
           """  
           st.markdown(card\_html, unsafe\_allow\_html=True)

       \# ... loop ...  
       \# create\_recommendation\_card(program)  
       \# if st.button("▶️ 이 프로그램 다음 채널 추천", key=f"next\_up\_{program\['title'\]}"):  
       \#    \# Next-Up 로직 실행

   * '이어서 보기' 로직은 st.session\_state를 활용하여 상태를 관리한다. 버튼이 클릭되면, st.session\_state.current\_selection\_end\_time에 해당 프로그램의 종료 시간을 저장하고, 페이지를 다시 실행(st.rerun())하여 다음 추천 목록을 그리도록 유도한다.

### **Part 5: 유틸리티 및 에러 처리 상세 설계**

프로젝트 전반의 코드 품질, 안정성, 유지보수성을 향상시키기 위한 공통 모듈과 전략을 설계한다.

#### **5.1. 모듈 7: 공통 헬퍼 (src/utils/helpers.py)**

* **파일**: src/utils/helpers.py  
* **역할**: 특정 도메인에 종속되지 않는 범용 함수들을 모아놓은 유틸리티 모듈.  
* **포함될 함수 명세**:  
  * **load\_config(path: str) \-\> dict**:  
    * YAML 설정 파일을 안전하게 로드하여 딕셔너리로 반환한다.  
  * **get\_project\_root() \-\> Path**:  
    * 프로젝트의 루트 디렉토리 경로를 반환하여, 어떤 위치에서 스크립트를 실행해도 파일 경로가 깨지지 않도록 보장한다.  
  * **setup\_logger(config\_path: str)**:  
    * config/logging\_config.json 파일을 읽어 Python의 logging 모듈을 전역적으로 설정한다. 이를 통해 모든 모듈에서 일관된 형식의 로그를 남길 수 있다.  
  * **time\_formatter(dt\_obj: datetime, format: str) \-\> str**:  
    * datetime 객체를 지정된 포맷의 문자열로 변환한다.  
  * **calculate\_cosine\_similarity(vec1, vec2)**:  
    * 두 개의 numpy 배열(벡터)을 입력받아 코사인 유사도를 계산하여 반환한다.

#### **5.2. 전역 에러 처리 및 로깅 전략**

* **로깅 설정 (config/logging\_config.json)**:  
  * **목표**: 로그 레벨(DEBUG, INFO, WARNING, ERROR)에 따라 다른 핸들러(콘솔, 파일)를 사용하고, 일관된 포맷을 유지한다.  
  * **예시 구조**:  
    {  
      "version": 1,  
      "disable\_existing\_loggers": false,  
      "formatters": {  
        "standard": {  
          "format": "%(asctime)s \- %(name)s \- %(levelname)s \- %(message)s"  
        }  
      },  
      "handlers": {  
        "console": {  
          "class": "logging.StreamHandler",  
          "formatter": "standard",  
          "level": "INFO"  
        },  
        "file": {  
          "class": "logging.handlers.RotatingFileHandler",  
          "formatter": "standard",  
          "filename": "logs/app.log",  
          "maxBytes": 10485760,  
          "backupCount": 5,  
          "level": "DEBUG"  
        }  
      },  
      "root": {  
        "handlers": \["console", "file"\],  
        "level": "DEBUG"  
      }  
    }

  * 애플리케이션 시작 시 setup\_logger를 호출하여 이 설정을 적용한다.  
  * 모든 print() 문은 logging.info() 또는 logging.debug() 등으로 대체한다.  
* **컴포넌트별 예외 처리**:  
  * **API 호출**: ContentLabeler, ScheduleCrawler 등 외부 서비스와 통신하는 모든 컴포넌트는 try-except 블록 내에서 실행되어야 하며, 재시도 로직을 포함해야 한다. (Part 2에서 설계됨)  
  * **파일 I/O**: DataLoader 등 파일을 읽고 쓰는 모든 작업은 FileNotFoundError, PermissionError 등을 처리하는 try-except 블록으로 감싸야 한다.  
  * **모델 로딩/추론**: RatingPredictor에서 모델 파일 로딩 실패 또는 추론 중 발생하는 텐서 크기 불일치 등의 에러는 명시적으로 처리하고, 사용자에게 친화적인 메시지를 전달해야 한다.  
  * RecommendationEngine에서는 각 컴포넌트를 호출할 때 발생하는 예외를 최종적으로 처리하고, Streamlit UI에 에러 상태를 전달하여 st.error() 메시지를 표시하도록 한다.

#### **5.3. 데이터 유효성 검사 (Data Validation)**

* **목표**: 각 컴포넌트 간에 전달되는 데이터의 형식을 보장하여 예기치 않은 타입 에러를 방지한다. Pydantic 라이브러리 사용을 권장한다.  
* **구현 방안**:  
  * 각 주요 데이터 구조(e.g., 편성표 프로그램 정보, 최종 추천 결과)에 대한 Pydantic 모델을 src/core/schemas.py 파일에 정의한다.  
  * **예시 (src/core/schemas.py)**:  
    from pydantic import BaseModel, HttpUrl  
    from typing import List  
    from datetime import datetime

    class ProgramItem(BaseModel):  
        channel: str  
        title: str  
        start\_time: datetime  
        end\_time: datetime  
        similarity\_score: float  
        reason: str

    class RecommendationResult(BaseModel):  
        persona\_info: dict  
        dummy\_watch\_history: List\[dict\]  
        top\_k\_movies\_with\_labels: List\[dict\]  
        recommendations: List\[ProgramItem\]

  * RecommendationEngine의 generate\_recommendations\_for\_persona 메서드는 최종 반환 직전에 RecommendationResult(\*\*output\_dict)와 같이 Pydantic 모델로 데이터를 검증한다. 유효성 검사에 실패하면 ValidationError가 발생하며, 이를 try-except로 잡아 디버깅에 활용한다.

**(다음 파트에서 계속됩니다...)**